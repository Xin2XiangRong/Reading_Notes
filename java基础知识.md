### 一、面向对象

#### 1、什么是面向对象

**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了

**面向对象**则是从一个任务中抽取出各个角色（对象），这些角色分别提供了一些能力。然后，这些拥有能力的对象互相配合，完成任务，这样的好处是：各个对象可以通过不同的组合，完成不同的任务，这样可以提升代码重用，对代码做好分类和分级

**OPP**主要关注“怎么做”，即完成任务的具体细节；**OOP**则更贴近人类思维，主要关注“谁来做”，也就是完成任务的对象，而非细节。**AOP**是基于OOP延伸出来的编程思想，它进一步降低项目合作、维护、扩展、多人协作的成本，提高程序的内聚性，降低程序的耦合度。

##### 1）三大基本特征

https://www.cnblogs.com/fzz9/p/8973315.html  

**封装**的目的是增强安全性和简化编程，隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体。使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。

**继承**就是子类继承父类的特征和行为。抽取共有特征和方法形成高一层的类，继承机制允许创建分等级层次的类，可以很好的描述一个类的生态，也提高了代码的复用率。

**多态**是同一个行为具有多个不同表现形式或形态的能力。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。*多态的优点*：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。多态存在的*三个必要条件*：继承、重写、父类引用指向子类对象。——多态是在继承的基础上的。

##### 2）五大基本原则

* 单一职责原则（SRP）：一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。
* 开放封闭原则（OCP）：对象或实体应该对扩展开放，对修改封闭。
* 里氏替换原则（LSP）：在对象x为类型T时q(x)成立，那么当S是T的子类时，对象y为类型S时q(y)也应成立。（即对父类的调用同样适用于子类）
*  依赖倒置原则（DIP）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。
* 接口隔离原则（ISP）：不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多。

#### 2、平台无关性

java如何实现的平台无关         https://blog.csdn.net/newmemory/article/details/54949817  

Java在计算机的操作系统上又提供了一个java运行环境——JRE(安装JDK)。JRE由Java虚拟机、类库和一些核心文件组成，也就是说平台提供了java运行环境，Java编写的软件就可以在其上运行。Java语言提供的编译器不针对特定的操作系统和CPU芯片进行编程，而是针对Java虚拟机把Java源程序编译成称为字节码的“中间代码”，然后Java虚拟机负责将字节码翻译成虚拟机所在平台的机器码，并让当前平台运行该机器码。

**Java语言的运行原理**：在一个计算机上编译得到的字节码文件（就是.class文件），可以复制到任何一个安装了Java运行环境的计算机上直接运行。然后字节码文件由虚拟机负责解释执行，即Java虚拟机将字节码翻译成本地计算机的机器码，然后将机器码交给本地的操作系统运行。由于在一个计算机上编译得到的字节码文件可以复制到任何一个安装了Java运行环境的计算机上直接使用，所以字节码其实是一种“中间代码”，这也就是为什么“Java语言能够一次编译，处处运行，也就是Java跨平台的原因。”所以称Java是一种“半编译，半解释的语言”，即源程序——>编译——>字节码——>字节码解释程序——>对应平台的机器语言。

JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）

### 二、值传递、引用传递

https://www.cnblogs.com/binyue/p/3862276.html

**Java中数据类型分为两大类，基本类型和对象类型**。相应的，变量也有两种类型：基本类型和引用类型。基本类型的变量保存原始值，即它代表的值就是数值本身；而引用类型的变量保存引用值，“引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置。

基本数据类型包括：byte,short,int,long,char,float, double,boolean,returnAddress

引用类型包括：类类型、接口类型和数组

**变量的基本类型和引用类型的区别**：基本数据类型在声明时系统就给它分配空间；引用则不同，它声明时只给变量分配了引用空间，而不分配数据空间。

```java
int a;
a=10;//正确，因为声明a时就分配了空间
Date date;
//执行实例化，开辟数据空间存放Date对象，然后把空间的首地址传给today变量 
//date=new Date();
//如果注释掉上一步操作
//The local variable date may not have been initialized
//也就是说对象的数据空间没有分配
date.getDate()
```

**实际参数**是调用有参方法的时候真正传递的内容，而**形式参数**是用于接收实参内容的参数

**值传递**：方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。

**引用传递**：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。

这里要特殊考虑String，以及Integer、Double等几个基本类型包装类，它们都是immutable类型，因为没有提供自身修改的函数，每次操作都是新生成一个对象，所以要特殊对待，可以认为是和基本数据类型相似，传值操作。

**为什么说Java中只有值传递**   https://blog.csdn.net/bjweimengshu/article/details/79799485

无论是值传递还是引用传递，其实都是一种求值策略(Evaluation strategy)。在求值策略中，还有一种叫做按共享传递(call by sharing)。其实Java中的参数传递严格意义上说应该是按共享传递。

按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。

简单点说，Java中的传递，是值传递，而这个值，实际上是对象的引用。而按共享传递其实只是按值传递的一个特例罢了。所以我们可以说Java的传递是按共享传递，或者说Java中的传递是值传递。

### 三、重写与重载

https://blog.csdn.net/justlpf/article/details/80056899

Override（重写）

1. 方法名、参数、返回值相同
2. 子类方法不能缩小父类方法的访问权限
3. 子类方法不能抛出比父类方法更多的异常
4. 存在于父类和子类之间
5. 方法被定义为final不能被重写

Overload（重载）

1. 参数类型、个数、顺序至少有一个不相同
2. 不能重载只有返回值不同的方法名
3. 存在于父类和子类、同类中

### 四、Java的继承与实现

https://blog.csdn.net/jiahao1186/article/details/83021993

继承：如果多个类的某个部分的功能相同，那么可以抽象出一个类来，把他们的相同的部分都放到父类里，让他们都继承这个类

实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们实现这个接口，各自实现自己具体的处理方法来处理那个目标。

联系：继承和实现都能实现代码重用，提高开发效率。

区别：

1. 修饰不同：不同的修饰符修饰；实现：interface，继承：extends
2. 数量不同：单继承，多实现
3. 属性不同：在接口中只能定义全局常量（static final），并且无实现方法；而在继承中可以定义属性方法、常量、变量等
4. 调用不同：某个接口被类实现时，在类中一定要实现接口中的抽象方法；而继承想调用那个方法就调用那个方法，毫无压力。

接口是对功能的描述（方法/行为），接口传达的意思是：拥有某种功能，能干嘛，比如：Serializable代表可序列化的。   继承是——什么是一种什么，继承传达的意思是：is-a，比如：猫 是一个 动物，猫就是动物的子类。

 ### 五、构造函数与默认构造函数

https://www.cnblogs.com/livterjava/p/4709561.html  

构造函数，是一种特殊的方法。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数)

构造函数的名称必须与类名相同，包括大小写；构造函数没有返回值，也不能用void修饰。如果不小心给构造函数前面添加了返回值类型，那么将使这个构造函数变成一个普通的方法，在运行时将产生找不到构造方法的错误。；一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参的默认构造器，这个构造器不执行任何代码；构造方法可以通过参数的个数、类型、顺序进行重载。

在函数的继承里,子类必须调用父类的构造函数。但是,子类只能继承父类的默认构造函数,如果父类没有默认的构造函数,那子类不能从父类继承默认构造函数.这时子类必须使用super来实现对父类的非默认构造函数的调用.

在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。

### 六、类变量、成员变量和局部变量

https://blog.csdn.net/zhaomengszu/article/details/79371070

成员变量：定义在类中，方法体之外。变量在创建对象时实例化。成员变量可被类中的方法、构造方法以及特定类的语句块访问。

类变量：定义在类中，方法体之外，但必须要有 static 来声明变量类型。静态成员属于整个类，可通过对象名或类名来调用

局部变量：在方法、构造方法、语句块中定义的变量。其声明和初始化在方法中实现，在方法结束后自动销毁

成员变量和类变量的区别：

* 生命的周期不同： 成员变量随着对象的创建而存在，随着对象的回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。
* 调用方式不同： 成员变量只能被对象调用。 静态变量可以被对象调用，还可以被类名调用。
* 别名不同： 成员变量也称为实例变量。静态变量也称为类变量。
* 数据存储位置不同： 成员变量存储在堆内存的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。

什么时候定义静态成员？或者说：定义成员时，到底需不需要被静态修饰呢

成员分两种：

* 成员变量：（数据共享时静态化）。该成员变量的数据是否是所有对象都一样：如果是，那么该变量需要被静态修饰，因为是共享的数据；如果不是，那么就说这是对象的特有数据，要存储到对象中去。
* 成员函数：（方法中没有调用特有数据时就定义成静态）。该函数内是否访问了对象中的特有数据：如果有访问特有数据，那方法不能被静态修饰。如果没有访问过特有数据，那么这个方法需要被静态修饰。

### 七、java中变量作用域的理解

在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。

类级变量又称全局级变量或静态变量，需要使用static关键字修饰。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。 对象实例级变量就是成员变量，实例化后才会分配内存空间，才能访问。 方法级变量就是在方法内部定义的变量，就是局部变量。

说明：方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量；块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量；方法级和块级的变量必须被显示地初始化，否则不能访问。

### 八、Java基础知识

#### 8种基本数据类型

整型：byte、short、int、long   浮点型：float、double  布尔型：boolean  字符型：char

取值范围     https://blog.csdn.net/jaychouandkobe/article/details/44494439

* Byte占一个字节，也就是8位，而且byte是有符号整型。用二进制表示时，最高位为符号位：0代表正数，1代表负数。Max：01111111（十进制：2^8-1=127）

  负数在计算机中是以其补码形式存在的，负数的是怎么计算的？就是负数的绝对值的原码转为二进制再按位取反后加1。-128的绝对值128,128原码10000000取反01111111加1:10000000，故-128计算机中的表示就是1000000.      -2^7（-128）<byte<2^7-1(127)        

* 同理：short 2个字节，int 4个字节，long 8个字节，都是有符号整型。

* float 4个字节，double 8个字节

* char作为2个字节无符号整型，其范围为0--2^15

什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？

https://blog.csdn.net/aya19880214/article/details/45891581

#### 自动拆装箱

https://www.jianshu.com/p/547b36f04239

自动装箱就是Java自动将基础类型值转换成对应的包装类型，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Interger对象转换成int类型值的过程叫做拆箱。基础类型存储在栈内存中，在程序启动的时候就会被初始化。

在有些情况下，我们需要持有一系列的对象，也就是使用我们常用的集合类，在这里不展开说，然而集合类在设计的时候持有的是我们所有类型的单根超类，Object，在将对象装入集合的时候，对象都会被向上转型为Object类，然后取出的时候，又通过参数化类型，也就是我们常用的泛型菱形<>语法，转型为我们装入的原始类型，但是如果我们呢要持有的是基本类型呢？基础类型的并没有父类，所以集合类并不能持有他，那怎么办呢？于是Java为每一个基础类型封装了相应的包装类。

什么时候会发生自动拆装箱——赋值；方法调用传入参数；被操作符操作的时候；

自动拆装箱是怎么实现的——就是编译器帮我们自动调用了拆装箱的方法，以Integer/int为例子，自动装箱就是编译器自动调用了valueOf(int i)方法,自动拆箱自动调用了intValue()方法,其他基本类型类推。

**有哪些问题得注意**

* 性能问题：首先在堆内存中创建对象的消耗肯定是要比使用栈内存要多的，同时在自动拆装箱的时候，也有一定的性能消耗，如果在数据量比较大，或者是循环的情况下，频繁的拆装箱并且生成包装类的时候，对性能的影响就是一星半点了，所以不是特殊的需求，例如上述被集合持有的情况，还是使用基本类型而不是包装类。
* 重载与自动装箱
* 缓存值问题——在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。

#### String

字符串的不可变性   https://www.cnblogs.com/qingergege/p/5701011.html

一旦一个String对象在内存中创建，它将是不可改变的，所有的String类中方法并不是改变String对象自己，而是重新创建一个新的String对象。

