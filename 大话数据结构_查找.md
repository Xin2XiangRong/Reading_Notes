### 查找

#### 1.顺序表查找

又叫线性查找：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

~~~~c
//顺序查找，a为数组，n为要查找的数组长度，key为要查找的关键字
int Sequential_Search(int *a, int n, int Key) {
    int i;
    for (i=1; i<=n; i++) {
        if(a[i]==key) {
            return i;
        }
        return i;
    }
    return 0;
}
~~~~

这里的代码还可以优化，因为每次循环时都需要对i是否越界，即是否小于等于n做判断。事实上，**可以设置一个哨兵，可以解决不需要每次让i与n作比较。**

~~~c
//有哨兵顺序查找
int Sequential_Search2(int *a, int n, int key) {
    int i;
    a[0] = key; //设置a[0]为关键字值，这里称之为哨兵
    i = n;
    while(a[i]!=key) {
        i--;
    }
    return i; //返回0则说明查找失败
}
~~~

这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。

时间复杂度是O(n)。

#### 2.有序表查找

##### 2.1折半查找

又称为二分查找。它的前提是线性表中的记录必须是关键字有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。

~~~c
//折半查找
int Binary_Search(int *a, int n, int key) {
    int low,high,mid;
    low=1;    //定义最低下标为记录首位
    high=n;   //定义最高下标为记录末位
    while(low<=high) {
        mid=(low+high)/2;  //折半
        if(key<a[mid]) high=mid-1;//若查找值比中值小，最高下标调整到中位下标小一位
        else if(key>a[mid]) low=mid+1; //若查找值比中值大，最低下标调整到中位下标大一位
        else 
            return mid;  //若相等则说明mid即为查到的位置
    }
    return 0；
}
~~~

时间复杂度。  *折半查找等于是把静态有序查找表分成了两棵子树*，即查找结果只需要找其中的一半数据记录即可，等于工作量少了一半，然后继续折半查找，效率当然是非常高了。

二叉树的性质之一：“具有n个结点的完全二叉树的深度为![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/3333.JPG)。在这里尽管折半查找判定二叉树并不是完全二叉树，但同样相同的推导可以得出，最坏情况是查找到关键字或者查找失败的次数为![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/3333-1582812340127.JPG)

因此折半算法的时间复杂度为O(logn)。显然远远好于顺序查找的O(n)时间复杂度。

##### 2.2 插值查找

比如要在取值范围0~10000之间100个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。所以，折半查找还是有改进空间的。

可以将折半查找中的第八句略微等式变换后得到：![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/111.JPG)

也就是mid等于最低下标low加上最高下标high与low的差的一半。算法科学家们的考虑的就是将这个1/2进行改进，改进为下面的计算方案: ![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/111-1563098436028.JPG)

这可以让mid更靠近被查找的值。

**插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/111-1563098850124.JPG)**

应该说，从时间复杂度来看，它也是O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{0,1,2,2000,2001,……,999998,999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。

##### 2.3斐波那契查找 

？？？？？？

#### 3.线性索引查找

索引就是把一个关键字与它对应的记录相关联的过程。。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。

##### 3.1稠密索引

稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。。。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。

![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/1563687839825.png)

如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降

##### 3.2 分块索引

分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：1.块内无序；2.块间有序。

我们定义的分块索引的索引项结构分三个数据项：

+ 最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大
+ 存储了块中的记录个数，以便循环时使用
+ 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。

![](01_picture/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/1563689559144.png)

##### 3.3倒排索引

索引项的通用结构就是：次关键码和记录号表

其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。















