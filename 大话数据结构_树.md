## 大话数据结构

### 1.树

#### 1.1树的定义

树是n(n>=0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树。

* n>1时根结点是唯一的，不可能存在多个根结点
* m>0时，子树的个数是没有限制的，但他们一定是互不相交的

##### 1.1.1结点分类

树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为**结点的度（Degree）**。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根节点之外，分支结点也称为内部结点。**树的度**是树内部各结点的度的最大值

##### 1.1.2结点间关系

孩子（child）、双亲（parent）、兄弟（sibling）、子孙

##### 1.1.3树的其他相关概念

结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为**树的深度（Depth）或高度**。

如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为**有序树**，否则称为无序树。

**森林**是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。

|          线性结构          |           树结构           |
| :------------------------: | :------------------------: |
|   第一个数据元素：无前驱   |    根结点：无双亲，唯一    |
|  最后一个数据元素：无后继  |  叶结点：无孩子，可以多个  |
| 中间元素：一个前驱一个后继 | 中间结点：一个双亲多个孩子 |



#### 1.2树的抽象数据类型

| ADT                          | 树（tree）                                                   |
| ---------------------------- | ------------------------------------------------------------ |
| Data                         | 树是由一个根节点和若干棵子树构成。树中结点具有相同数据类型及层次关系 |
| **Operation**                |                                                              |
| InitTree(*T)                 | 构造空树T                                                    |
| DestroyTree（*T)             | 销毁树T                                                      |
| CreateTree（*T, definition） | 按definition中给出树的定义来构造树                           |
| ClearTree（*T)               | 若树T存在，则将树T清为空树                                   |
| TreeEmpty（*T)               | 若树T为空树，则返回true，否则返回false                       |
| TreeDepth（*T)               | 返回树的深度                                                 |
| Root（T)                     | 返回T的根结点                                                |
| Value(T, cur_e)              | cur_e为树T的一个结点，返回此结点的一个值                     |
| Assign(T,cur_e,value)        | 给树的结点cur_e赋值value                                     |
| Parent(T, cur_e)             | 若cur_e是树T的非根结点，则返回它的双亲，否则返回空           |
| LeftChild(T,cur_e)           | 若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空       |
| RightSibling(T,cur_e)        | 若cur_e有右兄弟，则返回它的右兄弟，否则返回空                |
| InsertChild(* T，* P， i，c) | 其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树 |
| DeleteChild(* T, * p, i)     | 其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树 |

#### 1.3树的存储结构

对于顺序存储结构，用一段地址连续的存储单元依次存储*线性表*的数据元素这是很自然的。但是对于树这种一对多的结构，要想表示出谁是谁的双亲、谁是谁的孩子，简单的顺序存储结构是不能满足树的实现要求的。不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。

##### 1.3.1双亲表示法

对于树，除了根节点外，其余每个结点不一定有孩子，但是一定有且仅有一个双亲。

在每个结点中，附设一个指示器指示其双亲结点在数组中的位置，其结点结构如下：

![1562120836175](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562120836175.png)

其中，data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。由于根结点没有双亲，约定根节点的位置域设置为-1.    图6-4-1

![1562122191090](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562122191090.png)

 表示如下：

![](C:\Users\chaishuai\Desktop\捕获.PNG)

这样的存储结构可以根据结点的parent指针很容易找到它的双亲结点，但是结点的孩子却需要遍历整个结构才可以知道。如果改进一下，增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。

![](C:\Users\chaishuai\Desktop\捕获.PNG)

对于有0个或一个孩子结点来说，这样的结构是解决了要找结点孩子的问题。甚至是有2个孩子，知道了长子是谁，另一个当然是次子了。

另一个问题场景，如果我们关注各兄弟之间的关系呢？可以增加一个右兄弟域来体现兄弟关系，也就是说，每个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果不存在，则赋值为-1.

![](C:\Users\chaishuai\Desktop\捕获.PNG)

如果结点的孩子很多，超过两个。我们有关注结点的双亲、又关注结点的孩子和兄弟，而且对时间遍历要求还比较高，那么我们就可以把此结构扩展为有双亲域、长子域、再有右兄弟域。*存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时在设计相应的结构*

##### 1.3.2孩子表示法

换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即**每个结点有多个指针域，其中每个指针指向一棵子树的根结点，吧这种方法叫做多重链表表示法**.不过，树的每个结点的度，也就是它的孩子个数是不同的，所以可以设计两种方案来解决。

**方案一**：一种是指针域的个数就等于树的度

![1562124401220](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562124401220.png)

其中data是数据域。child1到childd是指针域，用来指向该结点的孩子结点。

对于图6-4-1的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如下所示：

![1562126021979](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562126021979.png)

这种方法对于树中各结点的度相差很大时，显然是很浪费空间的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。为什么不按需分配空间呢，于是有了第二种方案

**方案二**：每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数

![1562132708374](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562132708374.png)

其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。

![1562133214784](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562133214784.png)

这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。

能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们*再对每个结点的孩子建立一个单链表*体现它们的关系。

这就是我们要讲的孩子表示法。具体办法是，**把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

![1562136866128](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562136866128.png)

为此，设计两种结点结构，一个是孩子链表的孩子结点，如下：![1562136965597](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562136965597.png)

其中child是数据域，用来存储某个结点在表头数组中的下标，next是指针域，用来存储指向某结点的下一个孩子结点的指针。

另一个是表头数组的表头结点，如下：![1562137301879](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562137301879.png)

其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。

这样的结构对于我们要找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可

如果需要知道某个结点的双亲是谁呢？比较麻烦，需要遍历整棵树才可以。但是如果双亲表示法和孩子表示法综合一下就直接解决问题了。

![1562138090421](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562138090421.png)

##### 1.3.3孩子兄弟表示法

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

结点结构如下：![1562138406166](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562138406166.png)

其中data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，rightsib是指针域，存储该结点的右兄弟结点的存储地址。对于图6-4-1的树，这种方法实现的示意图如下：

![1562138899158](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562138899158.png)

这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。当然，如果想找某个结点的双亲，这个表示法也是有缺陷的。如果真的有必要，完全可以再增加一个parent指针域来解决快速查找双亲的问题。

其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。把上图变变形，就成了下面的样子：

![1562139476802](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562139476802.png)

这样就可以充分利用二叉树的特性和算法来处理这棵树了。

#### 1.4二叉树的定义

对于在某个阶段都是两种结果的情形，比如开和关、0和1、真和假、上和下、对与错，正面与反面等，都适合用树状结构来建模，而这种树是一种很特殊的树状结构，叫做二叉树。

**二叉树（Binary tree）是n（n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成**

##### 1.4.1二叉树特点

+ 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点
+ 左子树和右子树是有顺序的，次序不能任意颠倒
+ 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

二叉树具有五种基本形态：1.空二叉树；2、只有一个根节点；3、根结点只有左子树；4、根节点只有右子树；5、根节点既有左子树又右子树

##### 1.4.2特殊二叉树

1. **斜树**：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。。。与线性表结构一样？对的，可以把线性表结构理解为树的一种特殊的表现形式。
2. **满二叉树**：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。
3. **完全二叉树 **：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。

完全二叉树的特点：

+ 叶子结点只能出现在最下两层
+ 最下层的叶子一定集中在左部连续位置
+ 倒数二层，若有叶子结点，一定都在右部连续位置。
+ 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况
+ 同样结点数的二叉树，完全二叉树的深度最小。

#### 1.5二叉树的性质

1. 在二叉树的第i层上至多有2^(n-1)个结点(i>=1)

2. 深度为k的二叉树至多有2^k-1个结点（K>=1)

3. 对任何一棵二叉树T。如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1.       设n1为度是1的结点树。则树T结点总数n=n0+n1+n2。   由于根节点只有分支出去，没有分支进入，所以分支线总数为结点总数减去1.用代数表达就是分支线总数=n-1=n1+2 * n2.由此可以推导出n0+n1+n2-1=n1+2 * n2.结论就是n0=n2+1.

4. 具有n个结点的完全二叉树的深度为[![img](file:///C:/Users/CHAISH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)]+1（[x]表示不大于x的最大整数）。深度为k的满二叉树的结点数n一定是2^k-1。对于n=2^k-1倒推得到满二叉树的深度为
   $$
   k=log_2(n+1)
   $$
   完全二叉树的叶子结点只会出现在最下面的两层。它的结点数一定少于等于同样深度的满二叉树的结点数2^k-1，但一定多于2^(k-1)-1。即满足2^(k-1)-1<n<2^k-1。由于结点数n是整数，n<=2^k-1意味着n<2^k,n>2^(k-1)-1,意味着n>=2(k-1)，所以2^(k-1)<=n<2^k。不等式两边取对数，得到k-1<=![img](file:///C:/Users/CHAISH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)<k，而k作为深度也是整数，因此k=[![img](file:///C:/Users/CHAISH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)]+1

5. 如果对一棵有n个结点的完全二叉树（其深度为[![img](file:///C:/Users/CHAISH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)]+1）的结点按层序编号，对任一结点i(1<=i<=n)有：1、如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]；2、如果2 * i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2 * i；3、如果2 * i+1>n，则结点i无右孩子，否则其右孩子是结点2 * i+1。

#### 1.6二叉树的存储结构

##### 1.6.1二叉树顺序存储结构

顺序存储对树这种一对多的关系结构实现起来比较困难，但是二叉树是一种特殊的树，由于它的特殊性，似的用顺序存储结构也可以实现。

二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。

![1562204880527](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562204880527.png)

将这棵二叉树存入 到数组中，相应的下标对应其同样的位置

![1562205475791](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562205475791.png)

由于完全二叉树严格的定义，所以顺序结构也可以表现出二叉树的结构来。对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过把不存在的结点设置为"^"而已。注意，小写字母的结点表示不存在。

![1562205810037](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562205810037.png)

![1562205879424](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562205879424.png)

考虑一种极端的情况，一棵深度为k的右斜树，它只有k个结点，却需要分配2^k-1个存储单元空间，这显然是对存储空间的浪费。。所以顺序存储结构一般只用于完全二叉树。

##### 1.6.2 二叉链表

既然顺序存储适用性不强，我们就要考虑链式存储结构。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表为二叉链表，结点结构图如下：![1562206243594](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562206243594.png)

其中data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。结构示意图如下：

![1562209056982](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562209056982.png)

就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表

#### 1.7遍历二叉树

##### 1.7.1二叉树遍历原理

**二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次切仅被访问一次。**

这里有两个关键词：访问和次序。访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计算。输出打印等，它算作是一个抽象操作。二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。

##### 1.7.2 二叉树遍历方法

二叉树的遍历方式可以很多，如果我们限制了从左到有的习惯方式，那么主要就分为四种

1. **前序遍历**：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。下图的遍历顺序为：ABDGHCEIF

![1562212620299](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562212620299.png)

2. **中序遍历**：若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。中序遍历的顺序为：GDHBAEICF
3. **后序遍历**：若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。后序遍历的顺序为：GHDBIEFCA
4. **层序遍历**：若树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。层序遍历的顺序为：ABCDEFGHI

研究这么多遍历的方法干什么？？计算机只有循环、判断等方式来处理，也就是说，它只会处理线性序列，而上面提到的四种遍历方法，其实都是在把树中的结点变成某种意义的线性序列，这给程序的实现带来了好处。另外不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进行各种不同的处理。

##### 1.7.3 前序遍历算法

二叉树的定义是用递归的方式，所以实现遍历算法也可以采用递归，而且极其简洁明了。前序遍历算法代码如下：

~~~~c
void PreOrderTraverse(BitTree T) {
    if (T == null) return;
    printf("%c", T->data); //显示结点数据，可以更改为其他对结点操作
    PreOrderTraverse(T->lchild); //再前序遍历左子树
    PreOrderTraverse(T->rchild); //最后先序遍历右子树
}
~~~~

##### 1.7.4 中序遍历算法

~~~~c
void InOrderTraverse(BitTree T) {
    if (T == null) return;
    InOrderTraverse(T->lchild); //中序遍历左子树
    printf("%c", T->data); //显示结点数据，可以更改为其他对结点操作
    InOrderTraverse(T->rchild); //最后中序遍历右子树
}
~~~~

##### 1.7.5 后序遍历算法

~~~~c
void PostOrderTraverse(BitTree T) {
    if (T == null) return;
    PostOrderTraverse(T->lchild); //后序遍历左子树
    PostOrderTraverse(T->rchild); //再后序遍历右子树
    printf("%c", T->data); //显示结点数据，可以更改为其他对结点操作
}
~~~~

##### 1.7.6 推导遍历结果

题目：已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，请问这棵二叉树的后序遍历结果是多少？

前序遍历序列为ABCDEF，第一个字母是A被打印出来，就说明A是根节点的数据。再由中序遍历序列是CBAEDF，可以知道C和B是A的左子树的结点，E、D、F是A的右子树的结点。

然后看前序遍历中的C和B，它的顺序是B在前，所以C应该是B的孩子，但是不能判断是左孩子还是右孩子。再看中序遍历CB，C在B前，所以C是B的左孩子。

再看前序中的D、E、F,那就意味着D是A的右孩子，E和F是D的子孙，注意，它们中有一个不一定是孩子，还可能是孙子。再看中序中EDF，由于E在D的左侧，而F在右侧，所以可以确定E是D 的左孩子，F是D的右孩子。

![1562237581807](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562237581807.png)

所以后序遍历结果为CBEFDA

#### 1.8 二叉树的建立

![1562238066876](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562238066876.png)

假设二叉树的结点均为一个字符，我们把刚才前序遍历AB#D##C##用键盘挨个输入。实现的算法如下：

~~~~c
//按前序输入二叉树中结点的值
//#表示空树，构造二叉链表表示二叉树T
void CreateBiTree(BitTree *T) {
    TElemType ch;
    scanf("%c", &ch);
    if (ch == '#') *T = null;
    else {
        *T = (BiTree) malloc(sizeof(BiTNode));
        if(!*T) 
            exit(OVERFLOW);
        (*T)->data=ch; //生成根节点
        CreateBiTree(&(*T)->lchild);//构造左子树
        CreateBiTree(&(*T)->rchild);//构造右子树
    }
}
~~~~

其实建立二叉树，也是利用了递归原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。当然，完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码生成结点和构造左右子树的代码顺序交换一下。另外，输入的字符也要做相应的更改。

#### 1.9 线索二叉树

##### 1.9.1线索二叉树原理

在下图中有许多的"^"，也就是空指针的存在，表示空间没有被充分的利用。

 ![1562326341305](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562326341305.png)

对于一个有n个结点的二叉链表，每个结点有指向做左右孩子的两个指针，所以一共是2n个指针域。而n个结点的二叉树一共有n-1条分支线，也就是说存在2n-(n-1)=n+1个空指针域。。另一方面，在做遍历时，比如中序遍历后，我们可以很清楚的知道任意一个结点的前驱、后继是哪一个。可是，这是建立在已经遍历过的基础之上。在二叉链表上，只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱、后继是谁。要想知道必须遍历一次。以后每次需要知道时，都必须先遍历一次

可以利用这些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址。**把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded Binary Tree）**

在中序遍历后，将所有的空指针域中的rchild改为指向它的后继结点。于是我们就可以知道H的后继是D，I的后继是B……

![1562328023709](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562328023709.png)

如果将二叉树的所有空指针域中的lchild改为指向当前结点的前驱。H的前驱是NULL,I的前驱是D……

![1562328272194](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562328272194.png)

把前驱和后继都画出来，就可以看出，其实线索二叉树等于把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来两棵方便。所以把对二叉树以某种次序遍历使其为线索二叉树的过程称作是**线索化**。

另外，需要一个标示，指定指针指向的是孩子还是前驱或后继。所以结点结构设计如下：

![1562328773310](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562328773310.png)

其中：ltag为0时指向该结点的左孩子，为1时指向该结点的前驱；rtag为0时指向该结点的右孩子，为1时指向该结点的后继；因此二叉链表图可以修改为如下：

![1562329196346](C:\Users\chaishuai\AppData\Roaming\Typora\typora-user-images\1562329196346.png)

##### 1.9.2线索二叉树结构实现

~~~~c
//二叉树的二叉线索存储结构定义
typedef enum {Link, Thread} PointerTag; //Lintk==1表示指向左右孩子指针；Thread==1表示指向前驱或后继的线索

typedef struct BiThrNode {
    TElemtype data;	//结点数据
    struct BiThrNode *lchjild, *rchild; //左右孩子指针
    PointerTag LTag;
    PointerTag RTag; //左右标志
} BiThrNode, *BiThrTree;
~~~~

线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历二叉树时才能得到，所以**线索化的过程就是在遍历的过程中修改空指针的过程**。

~~~~~c
BiThrTree pre; //全局变量，始终指向刚刚访问过的结点
void InThreading (BiThrTree p) {
    if(p) {
        InThreading(p->lchild); //递归左子树线索化
        if(!p->lchild) {
            p->LTag = Thread; //前驱线索
            p->lchild=pre; //左孩子指针指向前驱
        }
        if(!pre->rchild) { //前驱没有右孩子
            pre->RTag = Thread;
            pre->rchild = p; //前驱右孩子指针指向后继（当前结点p）
        }
        pre = p;  //保持pre指向p的前驱
        InTheading（p-rchild);//
    }
}
~~~~~

可以发现，和二叉树中序遍历的递归代码几乎完全一样。只不过将本是打印结点的功能改成了线索化的功能。    if(!p->lchild)表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了pre，所以可以将pre赋值给p->pre，并修改p->LTag=Tread(也就是定义为1)以完成前驱结点的线索化。   后继就要麻烦一点。因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre->rchild)表示如果为空，则p就是pre的后继，于是pre->rchild=p，并且设置pre->RTag=Thread，完成后继结点的线索化。  完成前驱和后继的判断后，将当前结点p赋值给pre，以便于下一次使用。

#### 1.10 树、森林与二叉树的转换

##### 1.10.1 数转换为二叉树

将树转换为二叉树的步骤：

1. 加线。在所有兄弟结点之间加一条连线。
2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
3. 层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。**注意第一个孩子是二叉树的左孩子，兄弟转换过来的孩子是结点的右孩子。**

![](F:\MyProject\mygit\Reading_Notes\树_结构图\微信图片_20190707122112.jpg)

##### 1.10.2 森林转换为二叉树

森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。

1. 把每个树转换为二叉树
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。

![](F:\MyProject\mygit\Reading_Notes\树_结构图\微信图片_20190707122100.jpg)

##### 1.10.3 二叉树转换为树

是树转换为二叉树的逆过程，也就是反过来做而已。

1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该节点与这些右孩子结点用线连接起来。

2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。

3. 层次调整。使之层次结构分明。

   ![](F:\MyProject\mygit\Reading_Notes\树_结构图\微信图片_20190707122122.jpg)

##### 1.10.4 二叉树转换为森林

判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根节点有没有右孩子，有就是森林，没有就是一棵树**。如果是转换成森林，步骤如下：

1. 从根节点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。
2. 再将每棵分离后的二叉树转换为树即可。

![](F:\MyProject\mygit\Reading_Notes\树_结构图\微信图片_20190707121946.jpg)

##### 1.10.5 树与森林的遍历

森林的遍历分为两种方式：

1. 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如6-11-5下面三课树的森林，前序遍历的结果就是ABCDEFGHJI
2. 后序遍历：先访问森林中第一棵树，后序遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。6-11-5森林，后序遍历序列的结果就是：BCDAFEJHIG

如果对6-11-5左侧二叉树进行分析可以发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。

#### 1.11 赫夫曼树及其应用

##### 1.11.1 赫夫曼树

在对试卷评分时，如果按照下面的代码进行转换：

~~~java
if (a<60) b = "不及格";
else if (a<70) b = "及格";
else if (a<80) b = "中等";
else if (a<90) b = "良好";
else b = "优秀";
~~~

粗略看没什么问题，可是通常都认为，一张良好的考卷应该是让学生成绩大部分处于中等或良好的范围，优秀和不及格都应该较少才对。而上面这样的程序，就使得所有的成绩都需要先判断是否及格，在逐级而上得到结果。输入量很大的时候，其实算法是有效率问题的。

如果在实际的学习生活中，学生的成绩在5个等级上的分布规律如下表：

|   分数   | 0~59 | 60~69 | 70~79 | 80~89 | 90~100 |
| :------: | ---- | ----- | ----- | ----- | ------ |
| 所占比例 | 5%   | 15%   | 40%   | 30%   | 10%    |

那么70分以上大约占总数80%的成绩都需要经过3次以上的判断才可以得到结果，这显然不合理。。仔细观测发现，中等成绩（70~79）比例最高，其次是良好成绩，不及格的所占比例最少。我们把这棵二叉树重新进行分配，改成如下：

![1562488594130](F:\MyProject\mygit\Reading_Notes\树_结构图\1562488594130.png)

##### 1.11.2 赫夫曼树定义与原理

先把这两棵二叉树简化成叶子结点带权的二叉树（树节点间的边相关的数叫做权Weight）。其中A表示不及格，B表示及格，C表示中等，D表示良好，E表示优秀。每个叶子的分支线上的数字就是刚才提到的五级分制的成绩所占百分比。

![1562490190612](F:\MyProject\mygit\Reading_Notes\树_结构图\1562490190612.png)

赫夫曼认为，**从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目统称为路径长度。树的路径长度就是从树根到每一结点的路径长度之和**。二叉树a的路径长度就是1+1+2+2+3+3+4+4=20，二叉树b的路径长度是1+2+3+3+2+1+2+2=16.

如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有结点的带权路径长度之和。**带权路径长度WPL最小的二叉树称作赫夫曼树。**也别被称为最优二叉树。

二叉树a的WPL=5 * 1+15 * 2+ 40 * 3 + 30 * 4 + 10 * 4 = 315; 这里5是A结点的权，1是A的路径长度，其他同理

二叉树b的WPL=5 * 3 + 15 * 3 + 40 * 2 + 30 * 2 + 10 * 2 = 220

这意味着如果有10000个学生的百分制成绩需要计算五级分制成绩，用二叉树a的判断方法，需要做31500次比较，而二叉树b的判断方法只需要22000次比较，少了三分之一的量，性能提高很多。

**构造赫夫曼树**

1. 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即A5、E10、B15、D30、C40.
2. 取头两个最小权值的结点作为一个新结点N1的两个子节点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子。新结点的权值为两个叶子权值的和5+10=15.
3. 将N1替换A与E，插入有序序列中，保持从小到大排列。即N1_15、B15、D30、C40.
4. 重复步骤2.将N1与B作为一个新结点N2的两个子结点。N2的权值=15+15=30.

这个转换过程下图：

![1562491483339](F:\MyProject\mygit\Reading_Notes\树_结构图\1562491483339.png)

通过刚才的步骤，可以得出构造赫夫曼树的**赫夫曼算法描述**

1. 根据给定的n个权值{w1,w2,……,wn}构成n棵二叉树的集合F={T1,T2,……,Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均为空。
2. 在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树上根节点的权值之和。
3. 在F中删除这两棵树，同时将新得到的二叉树加入F中。
4. 重复2和3步骤，直到F只含一棵树为止。这棵树就是赫夫曼树。

#####  1.11.3 赫夫曼编码

比如有一段文字“BADCADFEED”，要网络传输给别人，显然用二进制的数字（0和1）来表示是很自然的想法

| 字母       | A    | B    | C    | D    | E    | F    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 二进制字符 | 000  | 001  | 010  | 011  | 100  | 101  |

这样真正传输的数据就是编码后的“00100001101000011101100100011”，对方接收时可以按照3位一份来译码。如果一篇文章很长，这样的二进制也将非常可怕。而事实上，有的字母或汉字出现频率是不相同的，有的极高。

假设这六个字母的频率为A27、B8、C15、D15、E30、F5，合起来正好是100%，那就意味着，我们完全可以重新按照赫夫曼树来规划它们。

下面左图为构造赫夫曼树的过程权值显示，右图为将权值左分支改为0、右分支改为1后的赫夫曼树。

![1562493234843](F:\MyProject\mygit\Reading_Notes\树_结构图\1562493234843.png)

此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如下表这样的定义

| 字母       | A    | B    | C    | D    | E    | F    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 二进制字符 | 01   | 1001 | 101  | 00   | 11   | 1000 |

原编码二进制串：001000011010000011101100100011（共30个字符）

新编码二进制串：1001010010101001000111100（共25个字符）

当接收到压缩过的新编码是，应该如何把它解码出来呢？编码中非0即1，长短不等的话其实很容易混淆的，所以**若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码。**

在解码时，发送方和接收方必须要约定好同样的赫夫曼编码规则。

**一般的，设需要编码的字符集为{d1,d2,……,dn}，各个字符在电文中出现的次数或频率集合为{w1,w2,……，wn}，以d1,d2,……,dn作为叶子结点，以w1,w2,……,wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根节点到叶子结点所经过的路径分支组成0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码**










